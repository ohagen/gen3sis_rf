---
title: "2.1 Creating landscapes: cost functions and matrices symmetry"
subtitle: "all you need to know about how to write nice cost functions and how to make dispersal harder in specific directions"
date: "`r format(Sys.time(),  '%d.%m.%Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{2.1 Creating landscapes: cost functions and matrices symmetry}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r include = FALSE}
library(knitr)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  tidy=T,
  fig.align='center',
  tidy.opts = list(width.cutoff=80),
  results='hold'
)
```

# Introduction

In nature, species dispersal are often not symmetrical, i.e., it could be harder to follow some paths than others. For example, the topography of a region can be quite rugged, featuring areas of steep slopes. In this case, animal and plant dispersal may face resistence in directions of higher elevations, while descending is clearly less costly. Another example is river flow. Aquatic organisms may disperse more easily in the direction of the river flow instead against it. In these cases, when constructing a concise distance matrices to simulate species dispersal, a *asymmetrical* matrix is necessary, because moving from site A to site B ($A \rightarrow B$) could have different cost than moving $B \rightarrow A$.

In *gen3sis2* the symmetry of the distance matrices are straightforward controlled by the *cost_function* itself, which is highly customizable. In this vignette, we will see how to write many different forms of cost functions and how they impact the distance matrices.

# Starting simple: a cost function anatomy

In *gen3sis2*, user can construct (and are encouraged to) a multitude of cost functions. It have few rules: (1) it must follow R syntax; (2) it must return a single numerical value or *Inf*; (3) the first two arguments must be *source* and *dest*; and (4) any other argument used must have a default value. To do that, *gen3sis2* provide to the user useful information about the source and the destination cells:

a.  "index": Raster cell index

b.  "coordinates": Cell centroid coordinates

c.  "value": Variable values in cell

d.  "habitable": Habitability in cell

All the information is derived from the input raster used. Raster cell index is always an integer, and habitability is always boolean (TRUE or FALSE). They work as building blocks: user can organize and use them as wished. It is not mandatory to use all of them (or any, actually), but together they can produce very interesting dispersal rules, as we will see later.

In the previous vignette, we defined the following cost function:

```{r}
cf <- function(source, dest){
  if(!all(source$habitable, dest$habitable)) {
    return(2 / 1000)
  } else {
    return(1 / 1000)
  }
}
```

Note how that follows and the rules cited above. Most importantly, note that to call source and destination cells habitability information the \$ is used. This is because *source* and *dest* parameters will receive lists within the matrix calculations. For that reason, when manipulating cell information, R list syntax must be used.

To show how the cost functions deal with cells information, lets simulate two cells. Imagine the first two cells of a raster with temperature and air humidity information, that are in the same row and consecutive columns:

```{r}
source <- list(
  index = 1,
  coordinates = c("x"=0,"y"=0),
  value = c("temperature"=30, "air_humidity"=40),
  habitable = TRUE
)

dest <- list(
  index = 2,
  coordinates = c("x"=0,"y"=1),
  value = c("temperature"=35, "air_humidity"=25),
  habitable = TRUE
)
```

Inside the cost function, all the information can be accessed using simple list syntax, with \$. To explore that, imagine that the cost will be defined by the temperature difference between the cells divided by the mean air humidity. In that case, we will write the cost function as:

```{r}
cf <- function(source, dest){
  temp_difference <- (source$value[["temperature"]] - dest$value[["temperature"]])
  mean_humidity <- (source$value[["air_humidity"]] + dest$value[["air_humidity"]])/2
  cost <- temp_difference/mean_humidity
  
  return(cost)
}

cf(source, dest)
```

# Getting complex: adding an external information

One possibility to make more complex cost functions is to implement additional information or variables in it. To illustrate this, let's add a "base_cost = 1", to control cost values:

```{r}
cf <- function(source, dest, base_cost = 1){
  temp_difference <- (source$value[["temperature"]] - dest$value[["temperature"]])
  mean_humidity <- (source$value[["air_humidity"]] + dest$value[["air_humidity"]])/2
  cost <- temp_difference/mean_humidity
  
  return(base_cost+cost)
}

cf(source, dest)
```

Note that this can also be constructed in the working environment, what can be useful in many cases:

```{r}
base_cost <- 2

cf <- function(source, dest, base = base_cost){
  temp_difference <- (source$value[["temperature"]] - dest$value[["temperature"]])
  mean_humidity <- (source$value[["air_humidity"]] + dest$value[["air_humidity"]])/2
  cost <- temp_difference/mean_humidity
  
  return(base+cost)
}


cf(source, dest)
```

It is important to set whatever external variable used as a default value because *gen3sis2* will only pass *source* and *dest* parameters to user's cost functions.

Please note that this and other rules we'll use in this vignette don't necessarily make biological sense; they are merely examples.

# Distance matrices symmetry

## Symmetrical distance matrices

In *gen3sis2*, the symmetry of the distance matrices is controlled by the cost function. When a cost function does not define any condition that implies asymmetry (e.g., going south is easier than going north), it is automatically constructed in a symmetrical way. To illustrate this, let's create a very simple 3x3 raster with two variables.

Let's start simulating some temperature data:

```{r}
library(terra)

temp_1 <- terra::rast(matrix(c(
  35, 30, 25,
  35, 30, 25,
  35, 30, 25
), nrow = 3, ncol = 3))
names(temp_1) <- "timestep_1"

temp_2 <- terra::rast(matrix(c(
  32, 27, 22,
  32, 27, 22,
  32, 27, 22
), nrow = 3, ncol = 3))
names(temp_2) <- "timestep_2"

temperature = c(temp_1, temp_2)

plot(temperature)
```

Now, some air humidity data:

```{r}
library(terra)

ah_1 <- terra::rast(matrix(c(
  50, 40, 30,
  50, 40, 30,
  50, 40, 30
), nrow = 3, ncol = 3))
names(ah_1) <- "timestep_1"

ah_2 <- terra::rast(matrix(c(
  45, 35, 25,
  45, 35, 25,
  45, 35, 25
), nrow = 3, ncol = 3))
names(ah_2) <- "timestep_2"

air_humidiy = c(ah_1, ah_2)

plot(air_humidiy)
```

Nice. Now, we can create a input landscape using the *create_spaces_raster* function, just like in the previous vignette. We will use the *withr* package to save it in temporary directory, because we are only interested in the distance matrix. The cost function we will use is simple: the cost will be defined by the Euclidian distance between source and destination cells, multiplied by a predefined coeficient. Note how this imply symmetry, because the distance $d$ between cell $A$ and cell $B$ is equal the other way around; i.e., $d(AB)=d(BA)$. For the record, the Euclidian distance is defined as $$
d = \sqrt{(x_A-x_B)²+(y_A-y_B)²}
$$ where $x$ is the longitude (x coordinate) and $y$ is the latitude (y coordinate).

Let's get this going:

```{r}
library(gen3sis2)

cf <- function(source, dest, cost_coef = 0.01){
  euc_dist <- sqrt(((source$coordinates["x"]-dest$coordinates["x"])**2)+((source$coordinates["y"]-dest$coordinates["y"])**2))
  cost = cost_coef*euc_dist
  
  return(cost)
}

withr::with_tempdir({
  create_spaces_raster(
    raster_list = list(temperature = temperature, air_humidiy = air_humidiy),
    cost_function = cf,
    directions = 8,
    output_directory = file.path(getwd(),"output"),
    full_dists = TRUE,
    overwrite_output = TRUE,
    verbose = FALSE,
    duration = list(from = 50, to = 0, by = -50, unit = "Ma"),
    geodynamic = FALSE,
  )
  files_created <- list.files(file.path(getwd(), "output"), recursive = T)
  
  distances_local <- readRDS(file.path(getwd(), "output", "distances_local", "distances_local_0.rds"))
})

distances_local
```

As our rasters had 9 cells, our distance matrix is a 9x9 square matrix. Columns denote source cells, rows destination cells. Note, however, that not every cell is connected. We only computed the distances between a cell and its eight neighbors, using the *direction* argument. The symmetry of the matrix is pretty clear visually, with the main diagonal serving as a symmetry axis. For example, we can observe that going from cell 1 to 2 have the same cost than going from cell 2 to 1, 1112.142.

## Asymmetrical matrices

Now, consider that for some ecological reasons, the dispersal is influenced by the latitude. For example, going north is always harder than going south. To represent this, we will add a rule in the cost function (in for of a if-else conditional): when direction is north, double the *cost_coef*.

We can achieve this latitudinal condition by comparing the coordinates of the cells. If the y coordinate of the destination cell is higher than the y coordinate of the source cell, it is going north:

```{r}
cf <- function(source, dest, cost_coef = 0.01){
  if (source$coordinates["y"] < dest$coordinates["y"]) {
    cost_coef <- 3*cost_coef
  }
  
  euc_dist <- sqrt(((source$coordinates["x"]-dest$coordinates["x"])**2)+((source$coordinates["y"]-dest$coordinates["y"])**2))
  cost = cost_coef*euc_dist
  
  return(cost)
}
```

In the cost function above, we tripled the *cost_coef* in case the destination is up north. Let's see the impact of this in the distance matix:

```{r}
withr::with_tempdir({
  create_spaces_raster(
    raster_list = list(temperature = temperature, air_humidiy = air_humidiy),
    cost_function = cf,
    directions = 8,
    output_directory = file.path(getwd(),"output"),
    full_dists = TRUE,
    overwrite_output = TRUE,
    verbose = FALSE,
    duration = list(from = 50, to = 0, by = -50, unit = "Ma"),
    geodynamic = FALSE,
  )
  files_created <- list.files(file.path(getwd(), "output"), recursive = T)
  
  distances_local <- readRDS(file.path(getwd(), "output", "distances_local", "distances_local_0.rds"))
})

distances_local
```

The matrix still have the same format, however the values changed. Note that going from cell 4 to cell 1 cost 3313.270 (going north), but going from cell 1 to cell 4 cost 1105.757 (going south). Moreover, the costs to move south, west and east remained the same, because we did not set any rule to these situation. In resume, the cost function controls it all.

## Using external variables can make matrices more interesting

As cited above, species dispersion is influenced by environmental factors. One common influential landscape aspect in this sense is the elevation, e.g., because is more costly to disperse to higher than to lower elevations. In *gen3sis2*, these contexts when an external factor is relevant to dispersal can be easily modeled by asymmetrical matrices.

Let's assume a context where elevation plays a major role in dispersal. In this, when species are moving up to higher places the resistance is greater than moving down, to lower places.

First, let's simulate some elevation data. To spice the things up, we will set random values, but the central column (cells 2, 5 and 8) will have higher elevation:

```{r}
elevation <- terra::rast(matrix(c(
  runif(1,50,100),     runif(1,50,100),     runif(1,50,100),
  runif(1,50,100)+100, runif(1,50,100)+100, runif(1,50,100)+100,
  runif(1,50,100),     runif(1,50,100),     runif(1,50,100)
), nrow = 3, ncol = 3))

plot(elevation)
```

Now let's implement a cost function that uses our "elevation" raster. In this the Euclidean distance will be multiplied by the elevation, and the final cost will be divided by $10⁶$ for better visualization. Note that elevation does not need to be in the input variables to be used within the cost function:

```{r}
cf <- function(source, dest, elev = elevation){
  
  euc_dist <- sqrt(((source$coordinates["x"]-dest$coordinates["x"])**2)+((source$coordinates["y"]-dest$coordinates["y"])**2))
  
  cost <- terra::values(elev)[dest$index]*euc_dist
  
  return(cost/1e6)
}

withr::with_tempdir({
  create_spaces_raster(
    raster_list = list(temperature = temperature, air_humidiy = air_humidiy),
    cost_function = cf,
    directions = 8,
    output_directory = file.path(getwd(),"output"),
    full_dists = TRUE,
    overwrite_output = TRUE,
    verbose = FALSE,
    duration = list(from = 50, to = 0, by = -50, unit = "Ma"),
    geodynamic = FALSE,
  )
  files_created <- list.files(file.path(getwd(), "output"), recursive = T)
  
  distances_local <- readRDS(file.path(getwd(), "output", "distances_local", "distances_local_0.rds"))
})

distances_local
```

Note how intricate and complex the matrix got. Multiple factors are influencing the dispersal and we represented it using only the cost function.

# Conclusion

This vignette provides a comprehensive guide to crafting highly customizable cost functions within the *gen3sis2* framework. We've explored the fundamental anatomy of a cost function, emphasizing its adherence to R syntax, the requirement for a single numerical or _Inf_ return value, and the mandatory *source* and *dest* arguments that provide detailed cell information.

A key takeaway is the profound impact of cost functions on distance matrix symmetry. By default, if no directional bias is encoded, *gen3sis2* generates symmetrical matrices, where the cost of moving from A to B is identical to moving from B to A. However, we've demonstrated how incorporating conditional logic based on cell coordinates (e.g., latitude) or external environmental variables (e.g., elevation), for example, allows for the creation of asymmetrical matrices. This capability is valuable for accurately representing natural dispersal phenomena where movement might be easier or harder in specific directions. The ability to integrate external variables, even those not explicitly part of the primary raster input, further enhances the flexibility and ecological realism of dispersal simulations in *gen3sis2*.